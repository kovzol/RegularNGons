<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>
    RegularNGons
  </title>
    <style>
      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      textarea.emscripten { font-family: monospace; width: 80%; }
      .outer { display: table; position: absolute; height: 100%; width: 100%; }
      .middle { display: table-cell; vertical-align: middle; }
      .inner { margin-left: auto; margin-right: auto; width: 1200px; }

    </style>
</head>
<body onload="go()">

  <div class="outer">
      <div class="middle">
          <div class="inner">

              <textarea class="emscripten" id="output" rows="10" cols="80">Welcome to RegularNGons (https://github.com/kovzol/RegularNGons)...
</textarea><br><div id="applet_container" class="emscripten"></div>
          </div>
      </div>
  </div>


  <script type="text/javascript" src="https://cdn.geogebra.org/apps/deployggb.js"></script>

  <script type='text/javascript'>
    function compute(inputString) { // compute a Giac command and return the output
        caseval = Module.cwrap('caseval', 'string', ['string']);
        return caseval(inputString);
    }

    // https://css-tricks.com/snippets/javascript/get-url-variables/
    function getQueryVariable(variable)
    {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++) {
            var pair = vars[i].split("=");
            if(pair[0] == variable){return pair[1];}
        }
        return(false);
    }

    function good(a,b,c,d) {
        if (a==b || a==c || a==d || b == c || b == d || c == d) {
            return false;
        }
        if (a>=n || b >= n || c>=n || d>=n) {
            return false;
        }
        var j;
        var es = efghlist.length;
        for (j=0; j<es; ++j) {
            if (efghlist[j] == c + "," + d + "," + a + "," + b)
                return false;
        }
        return true;
    }

    function go() {
        n = getQueryVariable("n");
        if (!n) errorOutput("Please append &n=... to the URL");
        if (n<5) errorOutput("Invalid n: " + n + " (please use a number >= 5)");
        cd = (n-2)*(n-3)/2-(n-4);
        efgh = n*(n-1)/2* (n-2)*(n-3)/2 /2;
        smax = (n-4)*cd*efgh;
        // on startup
        if (typeof s === 'undefined') {
            // Setup GeoGebra
            var parameters = {
                "id":"ggbApplet",
                "width":960,
                "height":600,
                "showToolBar":true,
                "borderColor":null,
                "showMenuBar":true,
                "allowStyleBar":true,
                "showAlgebraInput":false,
                "enableLabelDrags":true,
                "enableShiftDragZoom":true,
                "capturingThreshold":null,
                "showToolBarHelp":false,
                "errorDialogsActive":true,
                "showTutorialLink":true,
                "showLogging":true,
                "useBrowserForJS":false,
                "perspective":"AG"};

            var applet = new GGBApplet(parameters, '5.0', 'applet_container');
            applet.inject('applet_container');

            s = getQueryVariable("s");
            if (!s) {
                output("Assuming s=0, please append &s=... to the URL to override");
                s=0;
            }
            output("Starting with n=" + n + ", s=" + s);

            only1 = getQueryVariable("u");
            if (!only1) {
                only1=0;
            }
            if (only1==1) {
                output("Considering only unit results");
                ratonly=1;
            }

            ratonly = getQueryVariable("r");
            if (!ratonly) {
                output("Assuming r=0 ('rationals only' is off), please append &r=1 to the URL to override");
                ratonly=0;
            }
            if (ratonly==1 && only1==0) {
                output("Considering only rational results");
            }

            sol = 0;
            startTime = new Date();
            output("s can be incremented until " + smax);
            e = getQueryVariable("e");
            if (e) {
                output("Computation will stop at " + e);
            } else {
                e = smax;
            }
            output("Waiting for the CAS...")
        }
        if (s<0 || s>=smax) errorOutput("Invalid s: " + s);
        A = 0;
        var Bpos = s;
        var Bmax = n-4;
        var Bslice = smax/Bmax;
        B = Math.floor(Bpos/Bslice);
        var CDpos = Bpos - B * Bslice;
        B += 2;
        console.log("A = 0");
        console.log("B = " + B);
        var CDmax = cd;
        var CDslice = Bslice/CDmax;
        var CD = Math.floor(CDpos/CDslice);
        console.log("Bpos = " + Bpos + ", Bmax = " + Bmax + ", Bslice = "
             + Bslice + ", CDpos = " + CDpos + ", CDmax = " + CDmax
             + ", CDslice = " + CDslice);
        console.log("CD = " + CD);

        C = 1;
        D = C+1;
        CDsave = CD;
        while (CD > -1) {
            if (D<n-1) D++;
            else {
                C++;
                D = C+2;
            }
            // is C=B or D=B?
            if (C==B) {
                C++;
                D++;
            }
            if (D==B) {
                D++;
            }
            console.log("Considering C = " + C + ", D = " + D);
            if (B-A != C-D) {
                console.log("B-A = " + (B-A)+ ", C-D = " + (C-D) + " normal case, allowed");
                CD--;
            } else {
                console.log("B-A = " + (B-A)+ ", C-D = " + (C-D) + " parallel case, disallowed");
            }
        }
        CD = CDsave;
        console.log("C = " + C + ", D = " + D);

        var EFGHpos = CDpos - CD * CDslice;
        var EFGHmax = efgh;
        var EFGHslice = CDslice/EFGHmax;
        var EFGH = Math.floor(EFGHpos/EFGHslice);
        console.log("EFGHpos = " + EFGHpos + ", EFGHmax = " + EFGHmax + ", EFGHslice = "
           + EFGHslice);
        console.log("EFGH = " + EFGH);

        EFGHsave = EFGH;
        var i = 0;
        efghlist = [];
        loop:
        for (E=0; E<n; E++)
            for (F=E+1; F<n; F++)
                for (G=0; G<n; G++)
                    for (H=G+1; H<n; H++) {
                        if (good(E,F,G,H)) {
                            EFGH--;
                            efghlist[i] = E + "," + F + "," + G + "," + H;
                            ++i;
                        }
                        if (EFGH<0) break loop;
                    }
        EFGH = EFGHsave;
        console.log("A = " + A + ", B = " + B + ", C = " + C + ", D = " + D + ", E = " + E + ", F = " + F + ", G = " + G + ", H = " + H);
    }

    function CASinitCommands() {
        var factorsqrfree = "factorsqrfree(p):=begin local pf,r,ii; pf:=factor(p); if (sommet(pf)!='*') begin if (sommet(pf)=='^') return op(pf)[0]; else begin if (sommet(pf)!=sommet(-x)) return pf; else return factorsqrfree(-pf); end; end; opf:=op(pf); r:=1; for ii from 0 to size(opf)-1 do r:=r*factorsqrfree(opf[ii]); od return r end";
        var cos2piOverNMinpoly = "cos2piOverNMinpoly(n):=begin local j, p, q, r; p:=simplify((tchebyshev1(n)-1)/(x-1)); for j from 1 to n/2 do q:=tchebyshev1(j)-1; r:=gcd(p,q); p:=simplify(p/r); od; return factorsqrfree(primpart(p)); end";
        compute("caseval(\"init geogebra\");");
        compute(factorsqrfree);
        compute(cos2piOverNMinpoly);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function doCAScomputation() {
        CASinitCommands();
        while (s<e-1) {
            CAScomputeCurrent();
            await sleep(10);
            s++;
            go();
        }
        outputElapsedTime();
        output("Finished after finding "+sol+" solutions")
    }

    function output(text) {
        console.log("OUTPUT: " + text);
        var element = document.getElementById('output');
        var oldValue = element.value;
        element.value = oldValue + text + "\n";
        element.scrollTop = 99999;
    }

    function outputElapsedTime() {
        var endTime = new Date();
        var timeDiff = endTime - startTime;
        timeDiff /= 1000;
        var seconds = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var minutes = Math.round(timeDiff % 60);
        timeDiff = Math.floor(timeDiff / 60);
        var hours = Math.round(timeDiff % 24);
        output("Elapsed time: " + hours + "h " + minutes + "m " + seconds + "s");
    }

    function errorOutput(text) {
        output(text);
        outputElapsedTime();
        throw(text);
    }

    function CAScomputeCurrent() {
        done = false;
        // c=cos(2pi/n)
        console.log("CAS computes n=" + n + ", s=" + s);
        var c = compute("subst(cos2piOverNMinpoly(" + n + "),[x=c]);");
        // s=sin(2pi/n)
        var s_ = "s^2+c^2-1";
        // A=0
        var d = "ax,ay";
        // P0=(0,0), P1=(1,0)
        var p = "p0x,p0y,p1x-1,p1y";
        var maxindex = Math.max(B,C,D,E,F,G,H);
        var v = "c,s,ax,ay,bx,b_y,cx,cy,dx,dy,ex,ey,fx,fy,gx,gy,hx,hy,qx,qy,rx,ry";
        // defining vertex points and segment endpoints
        for (i=0; i<=maxindex; ++i) {
            var px = "p" + i + "x";
            var py = "p" + i + "y";
            v += "," + px + "," + py;
            if (i>1) {
                var ppx = "p" + (i - 1) + "x";
                var ppy = "p" + (i - 1) + "y";
                var pppx = "p" + (i - 2) + "x";
                var pppy = "p" + (i - 2) + "y";
                p += ",-" + px + "-s*" + ppy + "+" + ppx + "+c*" + ppx + "+s*" + pppy + "-c*" + pppx;
                p += ",-" + py + "+" + ppy + "+c*" + ppy + "+s*" + ppx + "-c*" + pppy + "-s*" + pppx;
            }
            if (B==i) d += ",bx-" + px + ",b_y-" + py;
            if (C==i) d += ",cx-" + px + ",cy-" + py;
            if (D==i) d += ",dx-" + px + ",dy-" + py;
            if (E==i) d += ",ex-" + px + ",ey-" + py;
            if (F==i) d += ",fx-" + px + ",fy-" + py;
            if (G==i) d += ",gx-" + px + ",gy-" + py;
            if (H==i) d += ",hx-" + px + ",hy-" + py;
        }
        // AQB, CQD are collinear:
        var q="ax*qy+qx*b_y+bx*ay-ax*b_y-qx*ay-bx*qy,cx*qy+qx*dy+dx*cy-cx*dy-qx*cy-dx*qy";
        // ERF, GRH are collinear:
        var r="ex*ry+rx*fy+fx*ey-ex*fy-rx*ey-fx*ry,gx*ry+rx*hy+hx*gy-gx*hy-rx*gy-hx*ry";
        // the requested length is QR=d
        var qr="d^2-(qx-rx)^2-(qy-ry)^2";
        var ideal=c+","+s_+","+p+","+d+","+q+","+r+","+qr;
        var eliminatecommand = "eliminate([" + ideal + "],[" + v + "]);";
        var eliminate = compute(eliminatecommand);
        var factorscommand = "factors(" + eliminate + ");";
        var factors = compute(factorscommand);
        var factor1command = factors + "[0][0]";
        var factor1 = compute(factor1command);
        // don't consider d=0
        if (factor1 != "d") {
            var degreecommand = "degree(" + factors + "[0][0]);";
            var degree = compute(degreecommand);
            var deg = Number(degree);
            var accepted = false;
            var factorcommand;
            var factor;
            var solvecommand;
            var solve;
            if (ratonly==0) {
                accepted = (deg > 0 && deg < 3);
            } else {
                accepted = (deg == 1);
            }
            if (accepted) {
                factorcommand = "factor(" + eliminate + ");";
                factor = compute(factorcommand);
                solvecommand = "solve([" + factor + "=0,d>0])";
                solve = compute(solvecommand);
            }
            if (only1==1 && solve!="{{d=1}}") {
                accepted = false;
            }
            if (accepted) {
                output("n=" + n + ", s=" + s + ": A=" + A + ", B=" + B + ", C=" + C +
                    ", D=" + D + ", E=" + E + ", F=" + F + ", G=" + G + ", H=" + H + ": " + factor + ", " + solve);
                sol = sol + 1;
                var lAB;
                var lCD;
                var lEF;
                var lGH;
                if (A<B) lAB=A + "," + B; else lAB = B + "," + A;
                var ld = "l_{"+lAB+"}";
                if (!ggbApplet.exists(ld)) {
                    ggbApplet.evalCommand(ld + "=Line(A_{" + A + "},A_{" + B + "})");
                    ggbApplet.setColor(ld, 192, 192, 192);
                    ggbApplet.setLabelVisible(ld, false);
                }
                if (C<D) lCD=C + "," + D; else lCD = D + "," + C;
                var le = "l_{"+lCD+"}";
                if (!ggbApplet.exists(le)) {
                    ggbApplet.evalCommand(le + "=Line(A_{" + C + "},A_{" + D + "})");
                    ggbApplet.setColor(le, 192, 192, 192);
                    ggbApplet.setLabelVisible(le, false);
                }
                if (E<F) lEF=E + "," + F; else lEF = E + "," + F;
                var lf = "l_{"+lEF+"}";
                if (!ggbApplet.exists(lf)) {
                    ggbApplet.evalCommand(lf + "=Line(A_{" + E + "},A_{" + F + "})");
                    ggbApplet.setColor(lf, 192, 192, 192);
                    ggbApplet.setLabelVisible(lf, false);
                }
                if (G<H) lGH=G + "," + H; else lGH = H + "," + H;
                var lg = "l_{"+lGH+"}";
                if (!ggbApplet.exists(lg)) {
                    ggbApplet.evalCommand(lg + "=Line(A_{" + G + "},A_{" + H + "})");
                    ggbApplet.setColor(lg, 192, 192, 192);
                    ggbApplet.setLabelVisible(lg, false);
                }

                var pR1 = "R_{" + lAB + "," + lCD + "}";
                var pR2 = "R_{" + lCD + "," + lAB + "}";
                var pR;
                if (ggbApplet.exists(pR1)) pR = pR1;
                else if (ggbApplet.exists(pR2)) pR = pR2;
                else {
                    pR = pR1;
                    ggbApplet.evalCommand(pR + "=Intersect(" + ld + "," + le + ")");
                    ggbApplet.setVisible(pR,false);
                }

                var pS1 = "S_{" + lEF + "," + lGH + "}";
                var pS2 = "S_{" + lGH + "," + lEF + "}";
                var pS;
                if (ggbApplet.exists(pS1)) pS = pS1;
                else if (ggbApplet.exists(pS2)) pS = pS2;
                else {
                    pS = pS1;
                    ggbApplet.evalCommand(pS + "=Intersect(" + lf + "," + lg + ")");
                    ggbApplet.setVisible(pS,false);
                }

                var sRS = "RS_{"+sol+"}";
                ggbApplet.evalCommand(sRS + "=Segment("+pR+","+pS+")");
                ggbApplet.setLabelVisible(sRS, false);
                ggbApplet.setColor(sRS, 0, 0, 64);

            }
        }
        done = true;
    }

    </script>

  <script type='text/javascript'>
      var Module = {
        preRun: [],
        postRun: [],
        printErr: function(text) {
          if (0) { // XXX disabled for safety typeof dump == 'function') {
            dump(text + '\n'); // fast, straight to the real console
          } else {
            console.log(text);
          }
        },
        setStatus: function(text) {
          if (Module.setStatus.interval) clearInterval(Module.setStatus.interval);
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          if (m) text = m[1];
          console.log("Giac status = " + text);
          if (text == "") { // ready to go
              outputElapsedTime();
              output("...CAS is up and running");
              output("Setting up GeoGebra applet");
              ggbApplet.setCustomToolBar("0|14");
              // ggbApplet.setAxesVisible(false,false);
              ggbApplet.setAxesVisible(1,false,false,false);
              ggbApplet.evalCommand("A=(0,0)");
              ggbApplet.evalCommand("B=(1,0)");
              ggbApplet.evalCommand("poly1=Polygon(A,B,"+n+")");
              ggbApplet.setLabelVisible("poly1", false);
              for (i=0; i<n; ++i) {
                  var oldLabel = String.fromCharCode(65+i);
                  var newLabel = "A_{" + i + "}";
                  ggbApplet.renameObject(oldLabel, newLabel);
                  ggbApplet.setVisible(newLabel, false);
              }
              doCAScomputation();
          }
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
    </script>
  <script src="giac.js"></script>

</body>
</html>

